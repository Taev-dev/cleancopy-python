document: [version_comment _EOL] [node_anchor]
// Note: this is just temporary; it needs to get tied into the way we do
// comments, whatever that ends up being
version_comment: "<<<cleancopy>>>"

node_anchor: (node_line_content | pending_node_anchor | node_line_empty | comment_lines)+
pending_node_anchor: node_line_pending_node_title+ (pending_node_embed | pending_node_content)

pending_node_content: [pending_node_metadata_block] (_BLOCK_BEGIN node_anchor _BLOCK_END | node_line_pending_node_empty)
pending_node_embed: [pending_node_metadata_block] node_line_pending_node_embed_assignment [pending_node_metadata_block] (_BLOCK_BEGIN _node_line_embed+ _BLOCK_END | node_line_pending_node_empty)
pending_node_metadata_block: (node_line_pending_node_metadata | comment_lines)+

node_line_pending_node_empty: SYMBOL_NODE_EMPTY _EOL
node_line_pending_node_title: SYMBOL_NODE_DEF [TEXT_NODE_TITLE] _EOL
node_line_pending_node_metadata: TEXT_METADATA_KEY SYMBOL_METADATA_ASSIGNMENT TEXT_METADATA_VALUE _EOL
node_line_pending_node_embed_assignment: TEXT_METADATA_KEY_EMBED SYMBOL_METADATA_ASSIGNMENT TEXT_METADATA_VALUE _EOL

node_line_empty: _EMPTY_LINE _EOL
node_line_content: TEXT_CONTENT_LINE _EOL
_node_line_embed: TEXT_EMBED_LINE _EOL | _EMPTY_LINE _EOL

comment_lines: SYMBOL_COMMENT_BEGIN TEXT_COMMENT_LINE (_EOL TEXT_COMMENT_LINE)* SYMBOL_COMMENT_END _EOL


// Note that these will consume whitespace up until the next non-whitespace
// character, OR until a newline
SYMBOL_COMMENT_BEGIN: "<<<"
SYMBOL_COMMENT_END.2: />>>[^\S\r\n]*/
SYMBOL_NODE_DEF: />(?!>>)[^\S\r\n]*/
SYMBOL_NODE_EMPTY: /<(?!<<)[^\S\r\n]*/
SYMBOL_METADATA_ASSIGNMENT: /:[^\S\r\n]*/
TEXT_NODE_TITLE: /[^\r\n]+/
TEXT_METADATA_KEY: /(?!embed:)[A-z_][A-z0-9_\-]*/
TEXT_METADATA_KEY_EMBED: /embed(?=:)/
TEXT_COMMENT_LINE.1: /((?!>>>)[^\r\n])+/
TEXT_EMBED_LINE: /[^\r\n]+/
// These are temporary, just so that we can make small incremental progress
// without needing to implement the entire world
TEXT_METADATA_VALUE: /[^\r\n]+/
TEXT_CONTENT_LINE: /(?!<<<)[^\r\n]+/

// These terminals are used only by the lexer, in order to derive the ones
// in the declare block
// Note: we're not in multiline mode (unless we explicitly set it), so these
// don't necessarily perfectly match sublime's regex!
NEWLINE_THEN_EMPTY.2: /\r?\n[^\S\r\n]*(?=[\r\n]|$)/
NEWLINE_THEN_INDENTATION.1: /\r?\n[^\S\r\n]*(?=\S)/
%declare _BLOCK_BEGIN _BLOCK_END _EMPTY_LINE _EOL
