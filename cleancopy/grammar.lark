document: [version_comment _EOL] [node_anchor]
// Note: this is just temporary; it needs to get tied into the way we do
// comments, whatever that ends up being
version_comment: "<<<cleancopy>>>"

node_anchor: (node_line_content | pending_node_anchor | node_line_empty | comment_lines)+
pending_node_anchor: node_line_pending_node_title+ (pending_node_embed | pending_node_content)

pending_node_content: [pending_node_metadata_block] (_BLOCK_BEGIN node_anchor _BLOCK_END | node_line_pending_node_empty)
pending_node_embed: [pending_node_metadata_block] node_line_pending_node_embed_assignment [pending_node_metadata_block] (_BLOCK_BEGIN node_line_embed+ _BLOCK_END | node_line_pending_node_empty)
pending_node_metadata_block: (node_line_pending_node_metadata | comment_lines)+

node_line_pending_node_empty: SYMBOL_NODE_EMPTY _EOL
node_line_pending_node_title: SYMBOL_NODE_DEF [TEXT_NODE_TITLE] _EOL
node_line_pending_node_metadata: METADATA_KEY SYMBOL_METADATA_ASSIGNMENT metadata_value _EOL
node_line_pending_node_embed_assignment: METADATA_KEY_EMBED SYMBOL_METADATA_ASSIGNMENT METADATA_VALUE_STR _EOL

metadata_value: METADATA_VALUE_STR
              | METADATA_VALUE_NULL
              | METADATA_VALUE_TRUE
              | METADATA_VALUE_FALSE
              | METADATA_VALUE_NUMERIC

node_line_empty: _EMPTY_LINE _EOL
node_line_content: TEXT_CONTENT_LINE _EOL
node_line_embed: _RECOVERED_INDENTATION TEXT_EMBED_LINE _EOL | _EMPTY_LINE _EOL

comment_lines: SYMBOL_COMMENT_BEGIN TEXT_COMMENT_LINE (_EOL _RECOVERED_INDENTATION TEXT_COMMENT_LINE)* SYMBOL_COMMENT_END _EOL


// Note that these will consume whitespace up until the next non-whitespace
// character, OR until a newline
SYMBOL_COMMENT_BEGIN: "<<<"
SYMBOL_COMMENT_END.2: />>>[^\S\r\n]*/
SYMBOL_NODE_DEF: />(?!>>)[^\S\r\n]*/
SYMBOL_NODE_EMPTY: /<(?!<<)[^\S\r\n]*/
SYMBOL_METADATA_ASSIGNMENT: /:[^\S\r\n]*/
TEXT_NODE_TITLE: /[^\r\n]+/
TEXT_COMMENT_LINE.1: /((?!>>>)[^\r\n])+/
TEXT_EMBED_LINE.2: /[^\r\n]+/
// This is temporary, just so that we can make small incremental progress
// without needing to implement the entire world
TEXT_CONTENT_LINE: /(?!<<<)[^\r\n]+/


METADATA_KEY: /(?!embed:)[A-z_][A-z0-9_\-]*/
METADATA_KEY_EMBED: /embed(?=:)/
METADATA_VALUE_STR: /"(?!"")[^\r\n]*?(?<!\\)(\\\\)*?"|'(?!'')[^\r\n]*?(?<!\\)(\\\\)*?'/
METADATA_VALUE_NULL: "null"
METADATA_VALUE_TRUE: "true"
METADATA_VALUE_FALSE: "false"
%import common.SIGNED_NUMBER -> METADATA_VALUE_NUMERIC

// These terminals are used only by the lexer, in order to derive the ones
// in the declare block
// Note: we're not in multiline mode (unless we explicitly set it), so these
// don't necessarily perfectly match sublime's regex!
NEWLINE_THEN_EMPTY.12: /\r?\n[^\S\r\n]*(?=[\r\n]|$)/
NEWLINE_THEN_INDENTATION.11: /\r?\n[^\S\r\n]*(?=\S)/
%declare _BLOCK_BEGIN _BLOCK_END _EMPTY_LINE _EOL _RECOVERED_INDENTATION
